// ----- ANFANG game.js -----

// Spielbereich holen, HTML-Elemente, Bilder, Sound
const canvas = document.getElementById('gameCanvas');
let ctx;

// Robustere Prüfung für Canvas und Context
if (!canvas) { const errorMsg = "FEHLER: Das Canvas-Element mit der ID 'gameCanvas' wurde nicht im HTML gefunden!"; console.error(errorMsg); alert(errorMsg); throw new Error(errorMsg); }
else { ctx = canvas.getContext('2d'); if (!ctx) { const errorMsg = "FEHLER: Konnte den 2D-Kontext vom Canvas nicht erhalten."; console.error(errorMsg); alert(errorMsg); throw new Error(errorMsg); } else { console.log("Canvas/Context OK."); } }
// Weitere Elemente holen
const scoreDisplay = document.getElementById('score');
const timerDisplay = document.getElementById('timer');
const highScoreListElement = document.getElementById('highScoreList');
const currentLevelDisplay = document.getElementById('current-level-display');
const levelGoalDisplay = document.getElementById('level-goal-display');

// Bild- und Sound-Ladungen
const keyImage = new Image(); let keyImageLoaded = false; keyImage.onload = function() { console.log("Key Img OK."); keyImageLoaded = true; }; keyImage.onerror = function() { console.error("FEHLER: Key Img!"); }; keyImage.src = 'schluessel.png';
const obstacleImage = new Image(); let obstacleImageLoaded = false; obstacleImage.onload = function() { console.log("Obstacle Img OK."); obstacleImageLoaded = true; }; obstacleImage.onerror = function() { console.error("FEHLER: Obstacle Img!"); }; obstacleImage.src = 'blockade.png';
const playerImage = new Image(); let playerImageLoaded = false; playerImage.onload = function() { console.log("Player Img OK."); playerImageLoaded = true; }; playerImage.onerror = function() { console.error("FEHLER: Player Img!"); }; playerImage.src = 'spieler.png';
const enemyImage = new Image(); let enemyImageLoaded = false; enemyImage.onload = function() { console.log("Enemy Img OK."); enemyImageLoaded = true; }; enemyImage.onerror = function() { console.error("FEHLER: Enemy Img!"); }; enemyImage.src = 'hamster.png';
const gameBackgroundImage = new Image(); let gameBackgroundImageLoaded = false; gameBackgroundImage.onload = function() { console.log("BG Img OK."); gameBackgroundImageLoaded = true; }; gameBackgroundImage.onerror = function() { console.error("FEHLER: BG Img!"); }; gameBackgroundImage.src = 'backgroundGame.jpg';
const keyPickupSound = new Audio('coin.wav'); keyPickupSound.onerror = function() { console.error("FEHLER: Sound 'coin.wav'!"); };
const enemyHitSound = new Audio('klauen.wav'); enemyHitSound.onerror = function() { console.error("FEHLER: Sound 'klauen.wav'!"); };
const obstacleHitSound = new Audio('bumper.wav'); obstacleHitSound.onerror = function() { console.error("FEHLER: Sound 'bumper.wav'!"); };
const gameOverSound = new Audio('game_over.wav'); gameOverSound.onerror = function() { console.error("FEHLER: Sound 'game_over.wav'!"); };

// Spiel-Zustände & Level-Tracking
let gameState = 'ready';
let currentLevel = 1;
let obstacles = [];
let keys = [];
let audioUnlocked = false;
let scoreAtLevelStart = 0;
let levelKeysCollected = 0;
let allowInputAfter = 0;

// Globale Variablen für Endergebnis-Anzeige
let finalScoreForDisplay = 0;
let finalLevelForDisplay = 1;
let previousLevelSummaryText = null;

// Zustand für die gezeichneten Buttons
let startButtonRect = null;
let isHoveringStartButton = false;
let restartButtonRect = null;
let isHoveringRestartButton = false;

// Level-Konstanten & Einstellungen (Deine Werte)
const obstacleColor = '#888888';
const obstacleImageWidth = 80; const obstacleImageHeight = 45;
const minObstacleDistSq = (obstacleImageWidth + 40) * (obstacleImageWidth + 40);
const level1Time = 30; const targetKeysLevel1 = 20;
const level2Time = 40; const targetKeysLevel2 = 30; const obstacleCountLevel2 = 6;
const level3Time = 30; const targetKeysLevel3 = 10;
const level4Time = 40; const targetKeysLevel4 = 10; const obstacleCountLevel4 = 8;
const level5Time = 40; const targetKeysLevel5 = 15;
const level6Time = 60; const targetKeysLevel6 = 20; const obstacleCountLevel6 = 8;
const level7Time = 90; const targetKeysLevel7 = 25; const obstacleCountLevel7 = 10;

// Spiel-Variablen
let score = 0; let timeLeft = level1Time; const keySize = 40; const playerSpeed = 4;
const maxHighScores = 10;
const highScoreStorageKey = 'keyCollectorHighScores_v1'; let timerInterval;
let nextKeyNumber = 1; let levelStartMessage = ""; let levelGoalMessage = "";
const keySpawnMargin = 50;
const timeBonusMultiplier = 10;
const keyLimit = 5;

// Spieler-Objekt (mit 50x50)
const player = { x: canvas.width / 2 - 25, y: canvas.height / 2 - 25, width: 50, height: 50, color: '#3498db', dx: 0, dy: 0 };

// Gegner Setup
const enemyWidth = 40; const enemyHeight = 40; const enemyBaseSpeedMultiplier = 0.5; const enemySpeedIncrease = 0.15;
const enemyDirectionChangeInterval = 3000; const playerHitCooldown = 1000; let playerCanBeHit = true;
let enemies = [];

// === HILFSFUNKTION für Level-Parameter ===
function getLevelParameters(levelNum) { let params = { time: 0, keyTarget: 0, enemyCount: 0, obstacleCount: 0, goalString: "Error" }; switch (levelNum) { case 1: params.time = level1Time; params.keyTarget = targetKeysLevel1; params.enemyCount = 1; params.goalString = `Sammle ${targetKeysLevel1} Schlüssel!`; break; case 2: params.time = level2Time; params.keyTarget = targetKeysLevel2; params.enemyCount = 1; params.obstacleCount = obstacleCountLevel2; params.goalString = `Sammle ${targetKeysLevel2} Schlüssel!`; break; case 3: params.time = level3Time; params.keyTarget = targetKeysLevel3; params.enemyCount = 1; params.goalString = `Sammle Schlüssel 1-${targetKeysLevel3}!`; break; case 4: params.time = level4Time; params.keyTarget = targetKeysLevel4; params.enemyCount = 1; params.obstacleCount = obstacleCountLevel4; params.goalString = `Sammle Schlüssel 1-${targetKeysLevel4}!`; break; case 5: params.time = level5Time; params.keyTarget = targetKeysLevel5; params.enemyCount = 2; params.goalString = `Sammle Schlüssel 1-${targetKeysLevel5}!`; break; case 6: params.time = level6Time; params.keyTarget = targetKeysLevel6; params.enemyCount = 2; params.obstacleCount = obstacleCountLevel6; params.goalString = `Sammle Schlüssel 1-${targetKeysLevel6}!`; break; case 7: params.time = level7Time; params.keyTarget = targetKeysLevel7; params.enemyCount = 3; params.obstacleCount = obstacleCountLevel7; params.goalString = `Sammle Schlüssel 1-${targetKeysLevel7}!`; break; default: console.error("Ungültiges Level in getLevelParameters:", levelNum); } return params; }

// --- Tastatursteuerung ---
let keyState = {}; const controlKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd'];
window.addEventListener('keydown', function(e) { const keyLower = e.key.toLowerCase(); const isControlKey = controlKeys.includes(e.key) || controlKeys.includes(keyLower); if (isControlKey) { e.preventDefault(); } if (gameState === 'level_summary' && isControlKey) { if (Date.now() >= allowInputAfter) { console.log("Starte Level", currentLevel, "via Taste:", e.key); if (currentLevel > 7) { console.log("Letztes Level abgeschlossen, gehe zu Highscore/Win Screen."); finalLevelForDisplay = 7; checkAndSaveHighScore(score, finalLevelForDisplay); gameState = 'won'; try { if (audioUnlocked) { gameOverSound.currentTime = 0; gameOverSound.play().catch(err => console.warn("Sound Error (Game Over Won):", err.name, err.message));} } catch(err) { console.error("Sound Error (Game Over Won, äußerer Catch):", err); } } else { startGame(); } } else { console.log("Input (level summary) ignored - too soon."); } return; } if (gameState === 'running') { keyState[e.key] = true; updatePlayerMovement(); } });
window.addEventListener('keyup', function(e) { if (gameState === 'running') { keyState[e.key] = false; updatePlayerMovement(); } });
function updatePlayerMovement() { if (gameState !== 'running') { player.dx = 0; player.dy = 0; return; } player.dx = 0; player.dy = 0; if (keyState['ArrowLeft'] || keyState['a'] || keyState['A']) player.dx = -playerSpeed; if (keyState['ArrowRight'] || keyState['d'] || keyState['D']) player.dx = playerSpeed; if (keyState['ArrowUp'] || keyState['w'] || keyState['W']) player.dy = -playerSpeed; if (keyState['ArrowDown'] || keyState['s'] || keyState['S']) player.dy = playerSpeed; }

// --- Maus-Interaktion für Canvas-Buttons ---
function getMousePos(canvas, evt) { const rect = canvas.getBoundingClientRect(); return { x: evt.clientX - rect.left, y: evt.clientY - rect.top }; }
function isInsideRect(pos, rect) { if (!rect) return false; return pos.x > rect.x && pos.x < rect.x + rect.width && pos.y < rect.y + rect.height && pos.y > rect.y; }
function handleCanvasMouseMove(evt) { const mousePos = getMousePos(canvas, evt); let isHoveringAnyButton = false; if (gameState === 'ready' && startButtonRect) { const previouslyHovering = isHoveringStartButton; isHoveringStartButton = isInsideRect(mousePos, startButtonRect); if (isHoveringStartButton) isHoveringAnyButton = true; if (isHoveringStartButton !== previouslyHovering || isHoveringStartButton) { if (isHoveringStartButton) canvas.classList.add('clickable'); } } else { isHoveringStartButton = false; } if ((gameState === 'over' || gameState === 'won') && restartButtonRect) { const previouslyHovering = isHoveringRestartButton; isHoveringRestartButton = isInsideRect(mousePos, restartButtonRect); if (isHoveringRestartButton) isHoveringAnyButton = true; if (isHoveringRestartButton !== previouslyHovering || isHoveringRestartButton) { if (isHoveringRestartButton) canvas.classList.add('clickable'); } } else { isHoveringRestartButton = false; } if (!isHoveringAnyButton && canvas.classList.contains('clickable')) { canvas.classList.remove('clickable'); } }
function handleCanvasClick(evt) { const mousePos = getMousePos(canvas, evt); if (gameState === 'ready' && startButtonRect && isInsideRect(mousePos, startButtonRect)) { console.log("Start-Button auf Canvas geklickt! Bereite Level 1 vor..."); if (!audioUnlocked) { try { const playPromise = keyPickupSound.play(); if (playPromise !== undefined) { playPromise.then(_ => { keyPickupSound.pause(); keyPickupSound.currentTime = 0; console.log("Audio Context durch Canvas-Klick entsperrt."); }).catch(error => { console.warn("Audio entsperren bei Canvas-Klick fehlgeschlagen (Promise):", error.name); }); } audioUnlocked = true; } catch (err) { console.warn("Audio entsperren bei Canvas-Klick fehlgeschlagen (Catch):", err.name); audioUnlocked = true; } } currentLevel = 1; const params = getLevelParameters(currentLevel); levelStartMessage = "Level 1"; levelGoalMessage = `Ziel: ${params.goalString}\nZeit: ${params.time}s\nHamster: ${params.enemyCount}`; if (params.obstacleCount > 0) { levelGoalMessage += `\nVans: ${params.obstacleCount}`; } previousLevelSummaryText = null; gameState = 'level_summary'; allowInputAfter = Date.now() + 750; isHoveringStartButton = false; isHoveringRestartButton = false; canvas.classList.remove('clickable'); return; } if ((gameState === 'over' || gameState === 'won') && restartButtonRect && isInsideRect(mousePos, restartButtonRect)) { console.log("Neustart-Button auf Canvas geklickt!"); resetToReady(); isHoveringStartButton = false; isHoveringRestartButton = false; canvas.classList.remove('clickable'); return; } }

// --- Spiellogik: Zeichnen ---
function drawPlayer() { if (!ctx) return; if (playerImageLoaded) { try { ctx.drawImage(playerImage, player.x, player.y, player.width, player.height); } catch (imgError) { console.error("Fehler Spielerbild:", imgError); drawFallbackPlayer(); } } else { drawFallbackPlayer(); } }
function drawFallbackPlayer() { if (!ctx) return; ctx.fillStyle = player.color; ctx.fillRect(player.x, player.y, player.width, player.height); ctx.fillStyle = '#f1c40f'; ctx.fillRect(player.x + player.width / 4, player.y + player.height / 4, player.width / 2, player.width / 2); }
function drawKey(key) { if (!ctx) return; if (keyImageLoaded) { try { ctx.drawImage(keyImage, key.x, key.y, keySize, keySize); } catch (imgError) { console.error("Fehler Schlüsselbild:", imgError); drawFallbackKey(key); } } else { drawFallbackKey(key); } if (currentLevel >= 3 && typeof key.number === 'number') { ctx.fillStyle = 'white'; ctx.strokeStyle = 'black'; ctx.lineWidth = 2; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const textX = key.x + keySize / 2; const textY = key.y + keySize / 2; ctx.strokeText(key.number, textX, textY); ctx.fillText(key.number, textX, textY); } }
function drawFallbackKey(key){ if (!ctx) return; ctx.fillStyle = '#f1c40f'; ctx.fillRect(key.x, key.y, keySize, keySize); ctx.fillStyle = '#e67e22'; ctx.fillRect(key.x + keySize / 4, key.y + keySize * 0.8, keySize / 2, keySize / 3); }
function drawObstacles() { if (!ctx) return; obstacles.forEach(obstacle => { if (obstacleImageLoaded) { try { ctx.drawImage(obstacleImage, obstacle.x, obstacle.y, obstacle.width, obstacle.height); } catch (imgError) { console.error("Fehler Hindernisbild:", imgError); drawFallbackObstacle(obstacle); } } else { drawFallbackObstacle(obstacle); } }); }
function drawFallbackObstacle(obstacle) { if (!ctx) return; ctx.fillStyle = obstacleColor; if(obstacle && typeof obstacle.x === 'number'){ ctx.fillRect(obstacle.x, obstacle.y, obstacle.width || obstacleImageWidth, obstacle.height || obstacleImageHeight); } }
function drawEnemies() { if (!ctx) return; enemies.forEach(enemyUnit => { if (!enemyUnit) return; if (enemyImageLoaded) { try { ctx.drawImage(enemyImage, enemyUnit.x, enemyUnit.y, enemyUnit.width, enemyUnit.height); } catch (e) { console.error("Fehler Gegnerbild:", e); drawFallbackEnemy(enemyUnit); } } else { drawFallbackEnemy(enemyUnit); } }); }
function drawFallbackEnemy(enemyUnit) { if (!ctx || !enemyUnit) return; ctx.fillStyle = 'orange'; ctx.fillRect(enemyUnit.x, enemyUnit.y, enemyUnit.width, enemyUnit.height); ctx.fillStyle = 'black'; ctx.fillRect(enemyUnit.x + enemyUnit.width * 0.6, enemyUnit.y + enemyUnit.height * 0.2, 5, 5); }

// === HILFSFUNKTION für Kollision (FEHLTE VORHER) ===
function checkRectCollision(rect1, rect2) {
    if(!rect1 || !rect2) return false; // Basic check for valid inputs
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
}
// =============================================

// --- Spiellogik: Erstellen von Objekten ---
function generateObstacles(count) { obstacles = []; if (!canvas) return; const margin = 40; const centerMargin = 100; const maxSpawnAttempts = 30; console.log(`Generiere ${count} Hindernisse...`); const playerRect = { x: player.x, y: player.y, width: player.width, height: player.height }; for (let i = 0; i < count; i++) { let obstacleX, obstacleY, collision; let attempts = 0; do { collision = false; attempts++; obstacleX = Math.random() * (canvas.width - obstacleImageWidth - 2 * margin) + margin; obstacleY = Math.random() * (canvas.height - obstacleImageHeight - 2 * margin) + margin; const tempRect = {x: obstacleX, y: obstacleY, width: obstacleImageWidth, height: obstacleImageHeight}; const centerX = tempRect.x + tempRect.width / 2; const centerY = tempRect.y + tempRect.height / 2; if (Math.abs(centerX - canvas.width / 2) < centerMargin && Math.abs(centerY - canvas.height / 2) < centerMargin) { collision = true; continue; } if (checkRectCollision(tempRect, playerRect)) { collision = true; continue; } enemies.forEach(enemyUnit => { if(checkRectCollision(tempRect, enemyUnit)) collision = true; }); if(collision) continue; for (const other of obstacles) { const otherCenterX = other.x + other.width / 2; const otherCenterY = other.y + other.height / 2; const dx = centerX - otherCenterX; const dy = centerY - otherCenterY; const distSq = dx * dx + dy * dy; if (distSq < minObstacleDistSq) { collision = true; break; } } } while (collision && attempts < maxSpawnAttempts); if (attempts < maxSpawnAttempts) { obstacles.push({ x: obstacleX, y: obstacleY, width: obstacleImageWidth, height: obstacleImageHeight }); } else { console.warn(`Konnte nach ${maxSpawnAttempts} Versuchen kein Hindernis ${i + 1} platzieren.`); break; } } console.log(`${obstacles.length} Hindernisse generiert.`); }
function spawnRandomKey() { if (!canvas) return; if (keys.length < keyLimit) { let keyX, keyY, collision; const maxAttempts = 20; let attempt = 0; do { collision = false; attempt++; keyX = Math.random() * (canvas.width - keySize); keyY = Math.random() * (canvas.height - keySize); const keyRect = { x: keyX, y: keyY, width: keySize, height: keySize }; for (const obstacle of obstacles) { if (checkRectCollision(keyRect, obstacle)) { collision = true; break; } } if (collision) continue; enemies.forEach(enemyUnit => { if(checkRectCollision(keyRect, enemyUnit)) { collision = true; } }); if (collision) continue; for (const otherKey of keys) { const expandedKeyRect = { x: keyRect.x - keySpawnMargin, y: keyRect.y - keySpawnMargin, width: keyRect.width + 2 * keySpawnMargin, height: keyRect.height + 2 * keySpawnMargin }; if (checkRectCollision(expandedKeyRect, otherKey)) { collision = true; break; } } } while (collision && attempt < maxAttempts); if (!collision) { const key = { x: keyX, y: keyY, collected: false, number: null }; keys.push(key); } else { console.warn("Kein Platz für ZUFÄLLIGEN Schlüssel nach", maxAttempts, "Versuchen..."); } } }
function spawnNumberedKeys(count) { keys = []; if (!canvas) return; console.log(`Spawne ${count} nummerierte Schlüssel (mit Margin)...`); for (let i = 1; i <= count; i++) { let keyX, keyY, collision; const maxAttempts = 30; let attempt = 0; do { collision = false; attempt++; keyX = Math.random() * (canvas.width - keySize); keyY = Math.random() * (canvas.height - keySize); const keyRect = { x: keyX, y: keyY, width: keySize, height: keySize }; for (const obstacle of obstacles) { if (checkRectCollision(keyRect, obstacle)) { collision = true; break; } } if (collision) continue; enemies.forEach(enemyUnit => { if(checkRectCollision(keyRect, enemyUnit)) { collision = true; } }); if (collision) continue; for (const otherKey of keys) { const expandedKeyRect = { x: keyRect.x - keySpawnMargin, y: keyRect.y - keySpawnMargin, width: keyRect.width + 2 * keySpawnMargin, height: keyRect.height + 2 * keySpawnMargin }; if (checkRectCollision(expandedKeyRect, otherKey)) { collision = true; break; } } } while (collision && attempt < maxAttempts); if (!collision) { const key = { x: keyX, y: keyY, collected: false, number: i }; keys.push(key); } else { console.warn(`Kein Platz für Schlüssel Nr. ${i} (mit Margin) nach ${maxAttempts} Versuchen.`); } } console.log(`${keys.length} von ${count} Schlüsseln (mit Margin) platziert.`); }

// --- Spiellogik: Bewegung & Kollision ---
function movePlayer() { if (gameState !== 'running' || !canvas ) return; let nextX = player.x + player.dx; let nextY = player.y + player.dy; if (nextX < 0) nextX = 0; if (nextX + player.width > canvas.width) nextX = canvas.width - player.width; if (nextY < 0) nextY = 0; if (nextY + player.height > canvas.height) nextY = canvas.height - player.height; let canMoveX = true; let canMoveY = true; let collidedWithObstacle = false; const playerRectX = { x: nextX, y: player.y, width: player.width, height: player.height }; const playerRectY = { x: player.x, y: nextY, width: player.width, height: player.height }; for (const obstacle of obstacles) { if (checkRectCollision(playerRectX, obstacle)) { canMoveX = false; collidedWithObstacle = true; } if (checkRectCollision(playerRectY, obstacle)) { canMoveY = false; collidedWithObstacle = true; } } enemies.forEach(enemyUnit => { const enemyRect = { x: enemyUnit.x, y: enemyUnit.y, width: enemyUnit.width, height: enemyUnit.height }; if (checkRectCollision(playerRectX, enemyRect)) { canMoveX = false; } if (checkRectCollision(playerRectY, enemyRect)) { canMoveY = false; } }); if (collidedWithObstacle) { try { if (audioUnlocked) { obstacleHitSound.currentTime = 0; obstacleHitSound.play().catch(e => console.warn("Sound Error (Obstacle Hit):", e.name, e.message)); } } catch (e) { console.error("Sound Error (Obstacle Hit, äußerer Catch):", e); } } if (canMoveX) { player.x = nextX; } else { player.dx = 0; } if (canMoveY) { player.y = nextY; } else { player.dy = 0; } }
function checkCollisions() { if (!canvas || !scoreDisplay || !levelGoalDisplay) return; const playerRect = { x: player.x, y: player.y, width: player.width, height: player.height }; for (let i = keys.length - 1; i >= 0; i--) { const key = keys[i]; const keyRect = { x: key.x, y: key.y, width: keySize, height: keySize }; if (!key.collected && checkRectCollision(playerRect, keyRect)) { let collectedThisTurn = false; if (currentLevel >= 3) { if (key.number === nextKeyNumber) { collectedThisTurn = true; score++; nextKeyNumber++; try { if(audioUnlocked){ keyPickupSound.currentTime = 0; keyPickupSound.play().catch(e => console.warn("Sound Error (Key Pickup):", e.name, e.message)); } } catch(e) { console.error("Sound Error (Key Pickup, äußerer Catch):", e); } const currentLevelParams = getLevelParameters(currentLevel); if (nextKeyNumber > currentLevelParams.keyTarget) { endGame(); } else { levelGoalDisplay.textContent = `Nächster: ${nextKeyNumber}/${currentLevelParams.keyTarget}`; } } else { console.log(`Falscher Schlüssel! Erwartet: ${nextKeyNumber}, Berührt: ${key.number}`); collectedThisTurn = false; } } else if (currentLevel === 1) { collectedThisTurn = true; score++; try { if(audioUnlocked){ keyPickupSound.currentTime = 0; keyPickupSound.play().catch(e => console.warn("Sound Error (Key Pickup):", e.name, e.message)); } } catch(e) { console.error("Sound Error (Key Pickup, äußerer Catch):", e); } levelGoalDisplay.textContent = `Schlüssel: ${score}/${targetKeysLevel1}`; if (score >= targetKeysLevel1) { console.log("Level 1 Ziel erreicht!"); endGame(); } else { spawnRandomKey(); } } else if (currentLevel === 2) { collectedThisTurn = true; score++; levelKeysCollected++; console.log(`Level 2: ${levelKeysCollected}/${targetKeysLevel2} gesammelt.`); try { if(audioUnlocked){ keyPickupSound.currentTime = 0; keyPickupSound.play().catch(e => console.warn("Sound Error (Key Pickup):", e.name, e.message)); } } catch(e) { console.error("Sound Error (Key Pickup, äußerer Catch):", e); } levelGoalDisplay.textContent = `Schlüssel Lvl: ${levelKeysCollected}/${targetKeysLevel2}`; if (levelKeysCollected >= targetKeysLevel2) { console.log("Level 2 Ziel erreicht!"); endGame(); } else { spawnRandomKey(); } } if (collectedThisTurn) { scoreDisplay.textContent = score; keys.splice(i, 1); break; } } } }
function setEnemyRandomDirection(enemyUnit) { if(!enemyUnit) return; enemyUnit.speed = enemyUnit.speed || playerSpeed * enemyBaseSpeedMultiplier; const angle = Math.random() * Math.PI * 2; enemyUnit.dx = Math.cos(angle) * enemyUnit.speed; enemyUnit.dy = Math.sin(angle) * enemyUnit.speed; enemyUnit.lastDirectionChange = Date.now(); }
function applyPlayerHit() { if (playerCanBeHit && timeLeft > 0 && gameState === 'running') { console.log("Spieler getroffen! Zeit -2s"); timeLeft -= 2; if (timeLeft < 0) { timeLeft = 0; } if (timerDisplay) timerDisplay.textContent = timeLeft; try { if (audioUnlocked) { enemyHitSound.currentTime = 0; enemyHitSound.play().catch(e => console.warn("Sound Error (Enemy Hit):", e.name, e.message)); } } catch (e) { console.error("Sound Error (Enemy Hit, äußerer Catch):", e); } if (timeLeft <= 0) { console.log("Game Over - Zeit durch Treffer abgelaufen in Level", currentLevel); endGame(); return true; } playerCanBeHit = false; setTimeout(() => { playerCanBeHit = true; }, playerHitCooldown); return true; } return false; }
function reverseEnemyDirection(enemyUnit, collidedObjRect) { if (!enemyUnit) return; setEnemyRandomDirection(enemyUnit); }
function moveEnemies() { if (gameState !== 'running' || !canvas ) return; enemies.forEach((enemyUnit, index) => { if (!enemyUnit) return; if (Date.now() - enemyUnit.lastDirectionChange > enemyDirectionChangeInterval) { setEnemyRandomDirection(enemyUnit); } let nextX = enemyUnit.x + enemyUnit.dx; let nextY = enemyUnit.y + enemyUnit.dy; const enemyRectNext = { x: nextX, y: nextY, width: enemyUnit.width, height: enemyUnit.height }; const playerRect = { x: player.x, y: player.y, width: player.width, height: player.height }; if (checkRectCollision(enemyRectNext, playerRect)) { applyPlayerHit(); reverseEnemyDirection(enemyUnit, playerRect); return; } if (obstacles.length > 0) { for (const obstacle of obstacles) { if (checkRectCollision(enemyRectNext, obstacle)) { reverseEnemyDirection(enemyUnit, obstacle); return; } } } if (keys.length > 0) { for (const key of keys) { if (!key.collected) { const keyRect = { x: key.x, y: key.y, width: keySize, height: keySize }; if (checkRectCollision(enemyRectNext, keyRect)) { reverseEnemyDirection(enemyUnit, keyRect); return; } } } } for (let j = index + 1; j < enemies.length; j++) { const otherEnemy = enemies[j]; const otherEnemyRect = {x: otherEnemy.x, y: otherEnemy.y, width: otherEnemy.width, height: otherEnemy.height}; if(checkRectCollision(enemyRectNext, otherEnemyRect)) { reverseEnemyDirection(enemyUnit, otherEnemyRect); reverseEnemyDirection(otherEnemy, enemyRectNext); return; } } let hitWall = false; if ((nextX < 0 && enemyUnit.dx < 0) || (nextX + enemyUnit.width > canvas.width && enemyUnit.dx > 0)) { hitWall = true; } if ((nextY < 0 && enemyUnit.dy < 0) || (nextY + enemyUnit.height > canvas.height && enemyUnit.dy > 0)) { hitWall = true; } if(hitWall) { setEnemyRandomDirection(enemyUnit); enemyUnit.x = Math.max(0, Math.min(enemyUnit.x, canvas.width - enemyUnit.width)); enemyUnit.y = Math.max(0, Math.min(enemyUnit.y, canvas.height - enemyUnit.height)); return; } else { enemyUnit.x += enemyUnit.dx; enemyUnit.y += enemyUnit.dy; } }); }
function checkPlayerEnemyCollision() { if (gameState !== 'running' || !ctx ) return; const playerRect = { x: player.x, y: player.y, width: player.width, height: player.height }; enemies.forEach(enemyUnit => { if (!enemyUnit) return; const enemyRect = { x: enemyUnit.x, y: enemyUnit.y, width: enemyUnit.width, height: enemyUnit.height }; if (checkRectCollision(playerRect, enemyRect)) { applyPlayerHit(); } }); }

// --- Highscore Logik ---
function loadHighScores() { const scoresJSON = localStorage.getItem(highScoreStorageKey); try { return scoresJSON ? JSON.parse(scoresJSON) : []; } catch (e) { console.error("HS Load Error:", e); return []; } }
function saveHighScores(scores) { console.log("HS Save: Start", JSON.parse(JSON.stringify(scores))); scores.sort((a, b) => b.score - a.score); scores.splice(maxHighScores); try { const jsonString = JSON.stringify(scores); localStorage.setItem(highScoreStorageKey, jsonString); console.log(`HS Save: Erfolg (${scores.length} Einträge gespeichert).`); } catch(e) { console.error("HS Save Error:", e); } }
function displayHighScores() { if (!highScoreListElement) { return; } console.log("HS Display: Start"); const scores = loadHighScores(); highScoreListElement.innerHTML = ''; if (scores.length === 0) { highScoreListElement.innerHTML = '<li>Noch keine Highscores!</li>'; return; } console.log(`HS Display: Zeige ${scores.length} Einträge`); scores.forEach((scoreEntry, index) => { const li = document.createElement('li'); const levelText = scoreEntry.level ? `(Lvl ${scoreEntry.level})` : ''; li.innerHTML = `<span class="name-level-group"><span class="name">${index + 1}. ${scoreEntry.name || '??'}</span><span class="level">${levelText}</span></span><span class="score">${scoreEntry.score ?? '?'}</span>`; highScoreListElement.appendChild(li); }); console.log("HS Display: Fertig"); }
function checkAndSaveHighScore(currentCombinedScore, levelReached) { console.log(`HS Check: Kombi-Score ${currentCombinedScore} (Lvl ${levelReached})`); if (!highScoreListElement) return; if (currentCombinedScore === undefined || currentCombinedScore === null || currentCombinedScore <= 0) { console.log("HS Check: Score ist 0 oder weniger, nicht gespeichert."); return; } const scores = loadHighScores(); const lowestHighScore = scores.length < maxHighScores ? -Infinity : scores[scores.length - 1].score; console.log("HS Check: Niedrigster gespeicherter Score:", lowestHighScore); if (scores.length < maxHighScores || currentCombinedScore > lowestHighScore) { console.log("HS Check: Qualifiziert!"); let playerName = prompt(`Glückwunsch! Score: ${currentCombinedScore} (Level ${levelReached})\nGib deinen Namen ein (max. 15 Zeichen):`, "Spieler"); if (playerName) { playerName = playerName.trim().substring(0, 15); if (!playerName) playerName = "Anonym"; const newScoreEntry = { name: playerName, score: currentCombinedScore, level: levelReached }; console.log("HS Check: Neuer Eintrag:", newScoreEntry); scores.push(newScoreEntry); saveHighScores(scores); displayHighScores(); } else { console.log("HS Check: Abbruch durch User."); } } else { console.log("HS Check: Nicht qualifiziert."); } }

// --- Spielsteuerung & Screens Zeichnen ---
function drawRoundedRect(ctx, x, y, width, height, radius) { if (width < 2 * radius) radius = width / 2; if (height < 2 * radius) radius = height / 2; ctx.beginPath(); ctx.moveTo(x + radius, y); ctx.arcTo(x + width, y, x + width, y + height, radius); ctx.arcTo(x + width, y + height, x, y + height, radius); ctx.arcTo(x, y + height, x, y, radius); ctx.arcTo(x, y, x + width, y, radius); ctx.closePath(); }
function drawReadyScreen() { if (!ctx || !canvas) return; ctx.fillStyle = 'black'; ctx.fillRect(0, 0, canvas.width, canvas.height); const buttonWidth = 250; const buttonHeight = 70; const buttonX = (canvas.width - buttonWidth) / 2; const buttonY = (canvas.height - buttonHeight) / 2; const borderRadius = 15; startButtonRect = { x: buttonX, y: buttonY, width: buttonWidth, height: buttonHeight }; restartButtonRect = null; ctx.save(); ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'; ctx.shadowBlur = 10; ctx.shadowOffsetX = 5; ctx.shadowOffsetY = 5; const gradient = ctx.createLinearGradient(buttonX, buttonY, buttonX, buttonY + buttonHeight); if (isHoveringStartButton) { gradient.addColorStop(0, '#66bb6a'); gradient.addColorStop(1, '#388e3c'); } else { gradient.addColorStop(0, '#4CAF50'); gradient.addColorStop(1, '#357a38'); } ctx.fillStyle = gradient; drawRoundedRect(ctx, buttonX, buttonY, buttonWidth, buttonHeight, borderRadius); ctx.fill(); ctx.strokeStyle = '#2e7d32'; ctx.lineWidth = 2; ctx.stroke(); ctx.restore(); ctx.fillStyle = 'white'; ctx.font = 'bold 28px Arial, sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText("Spiel starten", buttonX + buttonWidth / 2, buttonY + buttonHeight / 2); }
function drawLevelSummaryScreen() { if (!ctx || !canvas) return; ctx.fillStyle = 'black'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = 'white'; ctx.textAlign = 'center'; let currentY = canvas.height / 2 - 120; ctx.font = 'bold 48px Arial'; ctx.fillText(levelStartMessage, canvas.width / 2, currentY); currentY += 60; if (previousLevelSummaryText) { ctx.font = '22px Arial'; ctx.fillStyle = '#ccc'; ctx.fillText(previousLevelSummaryText, canvas.width / 2, currentY); currentY += 50; } else { currentY += 20; } ctx.fillStyle = 'white'; const lines = levelGoalMessage.split('\n'); const lineHeight = 30; ctx.font = 'bold 26px Arial'; ctx.fillText(lines[0], canvas.width / 2, currentY); currentY += lineHeight + 5; ctx.font = '20px Arial'; for(let i = 1; i < lines.length; i++) { ctx.fillText(lines[i], canvas.width / 2, currentY + (i-1) * lineHeight); } ctx.font = '18px Arial'; ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; const promptY = currentY + (lines.length-1) * lineHeight + 40; ctx.fillText("Drücke Pfeiltasten oder WASD zum Fortfahren...", canvas.width / 2, promptY); }
function drawGameOverScreen() { if (!ctx || !canvas) return; ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, 0, canvas.width, canvas.height); const boxWidth = 350; const boxHeight = 250; const boxX = (canvas.width - boxWidth) / 2; const boxY = (canvas.height - boxHeight) / 2; const borderRadius = 15; startButtonRect = null; ctx.save(); ctx.shadowColor = 'rgba(0, 0, 0, 0.6)'; ctx.shadowBlur = 12; ctx.shadowOffsetX = 4; ctx.shadowOffsetY = 4; const gradient = ctx.createLinearGradient(boxX, boxY, boxX, boxY + boxHeight); gradient.addColorStop(0, '#d32f2f'); gradient.addColorStop(1, '#b71c1c'); ctx.fillStyle = gradient; drawRoundedRect(ctx, boxX, boxY, boxWidth, boxHeight, borderRadius); ctx.fill(); ctx.strokeStyle = '#7f0000'; ctx.lineWidth = 2; ctx.stroke(); ctx.restore(); ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.font = 'bold 36px Arial, sans-serif'; ctx.fillText("Spiel vorbei!", boxX + boxWidth / 2, boxY + 50); ctx.font = '24px Arial, sans-serif'; ctx.fillText(`Score: ${finalScoreForDisplay}`, boxX + boxWidth / 2, boxY + 100); ctx.font = '20px Arial, sans-serif'; ctx.fillText(`Level erreicht: ${finalLevelForDisplay}`, boxX + boxWidth / 2, boxY + 140); const rButtonWidth = 180; const rButtonHeight = 50; const rButtonX = boxX + (boxWidth - rButtonWidth) / 2; const rButtonY = boxY + boxHeight - rButtonHeight - 25; restartButtonRect = { x: rButtonX, y: rButtonY, width: rButtonWidth, height: rButtonHeight }; ctx.save(); const rGradient = ctx.createLinearGradient(rButtonX, rButtonY, rButtonX, rButtonY + rButtonHeight); if (isHoveringRestartButton) { rGradient.addColorStop(0, '#64b5f6'); rGradient.addColorStop(1, '#1976d2'); } else { rGradient.addColorStop(0, '#2196F3'); rGradient.addColorStop(1, '#0d47a1'); } ctx.fillStyle = rGradient; drawRoundedRect(ctx, rButtonX, rButtonY, rButtonWidth, rButtonHeight, 10); ctx.fill(); ctx.strokeStyle = '#0b3c7a'; ctx.lineWidth = 1.5; ctx.stroke(); ctx.restore(); ctx.fillStyle = 'white'; ctx.font = 'bold 20px Arial, sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText("Neustart", rButtonX + rButtonWidth / 2, rButtonY + rButtonHeight / 2); }
function drawWinScreen() { if (!ctx || !canvas) return; ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, 0, canvas.width, canvas.height); const boxWidth = 350; const boxHeight = 250; const boxX = (canvas.width - boxWidth) / 2; const boxY = (canvas.height - boxHeight) / 2; const borderRadius = 15; startButtonRect = null; ctx.save(); ctx.shadowColor = 'rgba(0, 0, 0, 0.6)'; ctx.shadowBlur = 12; ctx.shadowOffsetX = 4; ctx.shadowOffsetY = 4; const gradient = ctx.createLinearGradient(boxX, boxY, boxX, boxY + boxHeight); gradient.addColorStop(0, '#FFD700'); gradient.addColorStop(1, '#b8860b'); ctx.fillStyle = gradient; drawRoundedRect(ctx, boxX, boxY, boxWidth, boxHeight, borderRadius); ctx.fill(); ctx.strokeStyle = '#806000'; ctx.lineWidth = 2; ctx.stroke(); ctx.restore(); ctx.fillStyle = 'black'; ctx.textAlign = 'center'; ctx.font = 'bold 40px Arial, sans-serif'; ctx.fillText("GEWONNEN!", boxX + boxWidth / 2, boxY + 55); ctx.font = '24px Arial, sans-serif'; ctx.fillText(`Score: ${finalScoreForDisplay}`, boxX + boxWidth / 2, boxY + 110); const rButtonWidth = 180; const rButtonHeight = 50; const rButtonX = boxX + (boxWidth - rButtonWidth) / 2; const rButtonY = boxY + boxHeight - rButtonHeight - 25; restartButtonRect = { x: rButtonX, y: rButtonY, width: rButtonWidth, height: rButtonHeight }; ctx.save(); const rGradient = ctx.createLinearGradient(rButtonX, rButtonY, rButtonX, rButtonY + rButtonHeight); if (isHoveringRestartButton) { rGradient.addColorStop(0, '#64b5f6'); rGradient.addColorStop(1, '#1976d2'); } else { rGradient.addColorStop(0, '#2196F3'); rGradient.addColorStop(1, '#0d47a1'); } ctx.fillStyle = rGradient; drawRoundedRect(ctx, rButtonX, rButtonY, rButtonWidth, rButtonHeight, 10); ctx.fill(); ctx.strokeStyle = '#0b3c7a'; ctx.lineWidth = 1.5; ctx.stroke(); ctx.restore(); ctx.fillStyle = 'white'; ctx.font = 'bold 20px Arial, sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText("Neustart", rButtonX + rButtonWidth / 2, rButtonY + rButtonHeight / 2); }
function resetToReady() { if(timerInterval) clearInterval(timerInterval); if (!timerDisplay || !scoreDisplay || !canvas || !levelGoalDisplay || !currentLevelDisplay) { console.error("Fehler in resetToReady: Wichtige UI Elemente nicht gefunden!"); } gameState = 'ready'; currentLevel = 1; obstacles = []; keys = []; enemies = []; if(levelGoalDisplay) levelGoalDisplay.textContent = ""; if(levelGoalDisplay) levelGoalDisplay.className = ''; if(currentLevelDisplay) currentLevelDisplay.textContent = "1"; timeLeft = level1Time; if(timerDisplay) timerDisplay.textContent = timeLeft; score = 0; scoreAtLevelStart = 0; levelKeysCollected = 0; if(scoreDisplay) scoreDisplay.textContent = score; nextKeyNumber = 1; keyState = {}; if(player) { player.dx = 0; player.dy = 0; } playerCanBeHit = true; isHoveringStartButton = false; startButtonRect = null; isHoveringRestartButton = false; restartButtonRect = null; if(canvas) canvas.classList.remove('clickable'); audioUnlocked = false; allowInputAfter = 0; previousLevelSummaryText = null; console.log("Spiel zurückgesetzt zu 'ready'"); }
function endGame() { if (gameState !== 'running') return; const endedLevel = currentLevel; const baseScoreAtLevelEnd = score; const remainingTime = timeLeft; clearInterval(timerInterval); keyState = {}; updatePlayerMovement(); let proceed = false; let nextLevel = 0; let targetKeys = 0; const endedLevelParams = getLevelParameters(endedLevel); if (endedLevel >= 3) targetKeys = endedLevelParams.keyTarget; let pointsThisLevel = baseScoreAtLevelEnd - scoreAtLevelStart; let levelTimeBonus = Math.max(0, remainingTime) * timeBonusMultiplier; if (endedLevel === 1 && score >= targetKeysLevel1) { nextLevel = 2; proceed = true; } else if (endedLevel === 2 && levelKeysCollected >= targetKeysLevel2) { nextLevel = 3; proceed = true; } else if (endedLevel === 3 && nextKeyNumber > targetKeysLevel3) { nextLevel = 4; proceed = true; } else if (endedLevel === 4 && nextKeyNumber > targetKeysLevel4) { nextLevel = 5; proceed = true; } else if (endedLevel === 5 && nextKeyNumber > targetKeysLevel5) { nextLevel = 6; proceed = true; } else if (endedLevel === 6 && nextKeyNumber > targetKeysLevel6) { nextLevel = 7; proceed = true; } else if (endedLevel === 7 && nextKeyNumber > targetKeysLevel7) { console.log("Level 7 Ziel erreicht!"); score += levelTimeBonus; levelStartMessage = `Level ${endedLevel} Geschafft!`; previousLevelSummaryText = `Deine Punkte: ${pointsThisLevel} + ${levelTimeBonus} Zeitbonus = ${pointsThisLevel + levelTimeBonus}`; levelGoalMessage = `Super! End-Score: ${score}`; finalScoreForDisplay = score; finalLevelForDisplay = 7; currentLevel = 8; gameState = 'level_summary'; allowInputAfter = Date.now() + 750; if(levelGoalDisplay) { levelGoalDisplay.textContent = ""; levelGoalDisplay.className = ''; } canvas.classList.remove('clickable'); isHoveringStartButton = false; return; } if (proceed) { console.log(`Level ${endedLevel} OK. Bereite Level ${nextLevel} vor...`); score += levelTimeBonus; const nextLevelParams = getLevelParameters(nextLevel); levelStartMessage = `Level ${endedLevel} Geschafft!`; previousLevelSummaryText = `Deine Punkte: ${pointsThisLevel} + ${levelTimeBonus} Zeitbonus = ${pointsThisLevel + levelTimeBonus}`; let nextLevelInfo = `Level ${nextLevel}\nZiel: ${nextLevelParams.goalString}\nZeit: ${nextLevelParams.time}s\nHamster: ${nextLevelParams.enemyCount}`; if (nextLevelParams.obstacleCount > 0) { nextLevelInfo += `\nVans: ${nextLevelParams.obstacleCount}`; } levelGoalMessage = nextLevelInfo; currentLevel = nextLevel; gameState = 'level_summary'; allowInputAfter = Date.now() + 750; if(levelGoalDisplay) { levelGoalDisplay.textContent = ""; levelGoalDisplay.className = ''; } } else { if(gameState === 'won' || gameState === 'over') return; gameState = 'over'; console.log(`Spielende in Level ${endedLevel}.`); try { if (audioUnlocked) { gameOverSound.currentTime = 0; gameOverSound.play().catch(err => console.warn("Sound Error (Game Over Lose):", err.name, err.message));} } catch(err) { console.error("Sound Error (Game Over Lose, äußerer Catch):", err); } const finalTimeBonus = Math.max(0, remainingTime) * timeBonusMultiplier; const scoreToSave = baseScoreAtLevelEnd + finalTimeBonus; finalScoreForDisplay = scoreToSave; finalLevelForDisplay = endedLevel; console.log(`Game Over! BaseScore: ${baseScoreAtLevelEnd}, Restzeit: ${remainingTime}, Zeitbonus: ${finalTimeBonus}, Total: ${scoreToSave}`); canvas.classList.remove('clickable'); isHoveringStartButton = false; if(levelGoalDisplay) { levelGoalDisplay.textContent = ""; levelGoalDisplay.className = ''; } previousLevelSummaryText = null; checkAndSaveHighScore(scoreToSave, endedLevel); } }
function startGame() { if (!scoreDisplay || !timerDisplay || !levelGoalDisplay || !currentLevelDisplay || !canvas ) { console.error("Fehler bei startGame: Wichtige UI Elemente nicht gefunden!"); return; } console.log(`startGame: Level ${currentLevel} wird gestartet.`); const params = getLevelParameters(currentLevel); if (params.goalString === "Error") { gameState = 'ready'; return; } timeLeft = params.time; let enemyCount = params.enemyCount; let obstacleCount = params.obstacleCount; let goalDisplayString = ""; let currentTargetKeys = params.keyTarget; let speedMultiplierLevel = 0; if (currentLevel === 2) speedMultiplierLevel = 1; else if (currentLevel === 3) speedMultiplierLevel = 2; else if (currentLevel === 4 || currentLevel === 5) speedMultiplierLevel = 3; else if (currentLevel >= 6) speedMultiplierLevel = 4; let currentEnemySpeed = playerSpeed * (enemyBaseSpeedMultiplier + speedMultiplierLevel * enemySpeedIncrease); if (currentLevel === 1) { goalDisplayString = `Schlüssel: ${score}/${targetKeysLevel1}`; } else if (currentLevel === 2) { levelKeysCollected = 0; goalDisplayString = `Schlüssel Lvl: ${levelKeysCollected}/${targetKeysLevel2}`; } else if (currentLevel >= 3) { nextKeyNumber = 1; goalDisplayString = `Nächster: ${nextKeyNumber}/${currentTargetKeys}`; } console.log(`Gegner: ${enemyCount}, SpeedMultiplier: ${currentEnemySpeed / playerSpeed}, Hindernisse: ${obstacleCount}`); scoreAtLevelStart = score; currentLevelDisplay.textContent = currentLevel; levelGoalDisplay.textContent = goalDisplayString; levelGoalDisplay.className = 'highlight'; scoreDisplay.textContent = score; timerDisplay.textContent = timeLeft; gameState = 'running'; keys = []; keyState = {}; player.x = canvas.width / 2 - player.width / 2; player.y = canvas.height / 2 - player.height / 2; player.dx = 0; player.dy = 0; playerCanBeHit = true; if (timerInterval) clearInterval(timerInterval); enemies = []; for(let i = 0; i < enemyCount; i++) { const corner = Math.floor(Math.random() * 4); let startX, startY; const offset = i * (enemyWidth + 15); if (corner === 0) { startX = 40 + offset; startY = 40; } else if (corner === 1) { startX = canvas.width - enemyWidth - 40 - offset; startY = 40; } else if (corner === 2) { startX = 40 + offset; startY = canvas.height - enemyHeight - 40; } else { startX = canvas.width - enemyWidth - 40 - offset; startY = canvas.height - enemyHeight - 40; } startX = Math.max(0, Math.min(startX, canvas.width - enemyWidth)); startY = Math.max(0, Math.min(startY, canvas.height - enemyHeight)); let newEnemy = { x: startX, y: startY, width: enemyWidth, height: enemyHeight, speed: currentEnemySpeed, dx: 0, dy: 0, lastDirectionChange: Date.now() + Math.random()*500 }; setEnemyRandomDirection(newEnemy); enemies.push(newEnemy); console.log(`Gegner ${i+1}/${enemyCount} erstellt bei X:${startX.toFixed(0)}, Y:${startY.toFixed(0)}`); } obstacles = []; keys = []; if (obstacleCount > 0) { generateObstacles(obstacleCount); } if (currentLevel >= 3) { spawnNumberedKeys(params.keyTarget); } else { console.log(`Spawning initial ${keyLimit} random keys for Level ${currentLevel}`); for(let i=0; i < keyLimit; i++){ spawnRandomKey(); } } timerInterval = setInterval(() => { if (gameState !== 'running') { clearInterval(timerInterval); return; } timeLeft--; if (timerDisplay) timerDisplay.textContent = Math.max(0, timeLeft); if (timeLeft <= 0) { console.log("Zeit abgelaufen in Level", currentLevel); endGame(); } }, 1000); }
function gameLoop() { if (!ctx || !canvas) { return; } if (gameState === 'ready') { drawReadyScreen(); } else if (gameState === 'level_summary') { drawLevelSummaryScreen(); } else if (gameState === 'running') { ctx.clearRect(0, 0, canvas.width, canvas.height); if (gameBackgroundImageLoaded) { ctx.drawImage(gameBackgroundImage, 0, 0, canvas.width, canvas.height); } ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; ctx.fillRect(0, 0, canvas.width, canvas.height); drawObstacles(); movePlayer(); moveEnemies(); checkCollisions(); checkPlayerEnemyCollision(); drawPlayer(); drawEnemies(); keys.forEach(key => { if (!key.collected) drawKey(key); }); } else if (gameState === 'over') { drawGameOverScreen(); } else if (gameState === 'won') { drawWinScreen(); } requestAnimationFrame(gameLoop); }

// --- Initialisierung ---
function initPage() { console.log("initPage: Starte Initialisierung..."); if (!canvas || !ctx) { return; } canvas.addEventListener('mousemove', handleCanvasMouseMove); canvas.addEventListener('click', handleCanvasClick); displayHighScores(); resetToReady(); gameLoop(); console.log("initPage: Initialisierung abgeschlossen."); }
initPage();

// ----- ENDE game.js -----